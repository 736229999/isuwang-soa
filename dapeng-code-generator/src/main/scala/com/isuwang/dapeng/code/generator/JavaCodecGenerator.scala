package com.isuwang.dapeng.code.generator

import java.util

import com.isuwang.dapeng.core.metadata.DataType.KIND
import com.isuwang.dapeng.core.metadata._

import scala.xml.Elem

/**
 * JAVA生成器
 *
 * @author tangliu
 * @date 15/9/8
 */
class JavaCodecGenerator extends CodeGenerator {

  override def generate(services: util.List[Service], outDir: String, generateAll:Boolean , structs: util.List[Struct], enums:util.List[TEnum]): Unit = {}

  override def generate(services: util.List[Service], outDir: String): Unit = {

  }

  def toCodecTemplate(service:Service, namespaces:util.Set[String]): Elem = {
    //val structNameCache = new util.ArrayList[String]()

    return {
      <div>package {service.namespace.substring(0, service.namespace.lastIndexOf("."))};

        import com.isuwang.dapeng.core.*;
        import com.isuwang.soa.serializer.*;
        import com.isuwang.org.apache.thrift.*;
        import com.isuwang.org.apache.thrift.protocol.*;

        import java.io.BufferedReader;
        import java.io.InputStreamReader;

        import java.util.Optional;
        import java.util.concurrent.CompletableFuture;
        import java.util.concurrent.Future;

        /**
        * Autogenerated by Dapeng-Code-Generator (1.2.1)
        *
        * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
        *  @generated
        **/
        public class {service.name}Codec <block>

        {
        toMethodArrayBuffer(service.methods).map{(method: Method)=> {

          <div>
            public static class {method.name}_args <block>
            {toFieldArrayBuffer(method.request.getFields).map{(field: Field)=>{
              <div>
                private {toJavaDataType(field.getDataType)} {field.getName};
                public {toJavaDataType(field.getDataType)} get{field.name.charAt(0).toUpper + field.name.substring(1)}()<block>
                return this.{field.name};
              </block>
                public void set{field.name.charAt(0).toUpper + field.name.substring(1)}({toJavaDataType(field.getDataType)} {field.name})<block>
                this.{field.name} = {field.name};
              </block>
              </div>
            }
            }
            }

            @Override
            public String toString()<block>
              StringBuilder stringBuilder = new StringBuilder("<block>");
                {toFieldArrayBuffer(method.request.getFields).map{(field : Field) =>{
                  getToStringElement(field);
                }}}
                if(stringBuilder.lastIndexOf(",") > 0)
                stringBuilder.deleteCharAt(stringBuilder.lastIndexOf(","));
                stringBuilder.append("</block>");

              return stringBuilder.toString();
            </block>

          </block>


            public static class {method.name}_result <block>

            {toFieldArrayBuffer(method.response.getFields()).map{(field:Field)=>
              if(field.getDataType().getKind() == DataType.KIND.VOID) {
                <div>
                  @Override
                  public String toString()<block>
                  return "<block></block>";
                </block>
                </div>
              } else {
                <div>
                  private {toJavaDataType(method.response.getFields.get(0).getDataType)} success;
                  public {toJavaDataType(method.response.getFields.get(0).getDataType)} getSuccess()<block>
                  return success;
                </block>

                  public void setSuccess({toJavaDataType(method.response.getFields.get(0).getDataType)} success)<block>
                  this.success = success;
                </block>


                  @Override
                  public String toString()<block>
                  StringBuilder stringBuilder = new StringBuilder("<block>");
                    {toFieldArrayBuffer(method.response.getFields).map{(field : Field) =>{
                      getToStringElement(field);
                    }}}
                    stringBuilder.deleteCharAt(stringBuilder.lastIndexOf(","));
                    stringBuilder.append("</block>");

                  return stringBuilder.toString();
                </block>

                </div>
              }
            }}
          </block>


            public static class {method.name}{lt}I extends {service.getNamespace + "." + service.name}{gt} extends SoaProcessFunction{lt}I, {method.name}_args, {method.name}_result, {method.name.charAt(0).toUpper + method.name.substring(1)}_argsSerializer,  {method.name.charAt(0).toUpper + method.name.substring(1)}_resultSerializer{gt}<block>
            public {method.name}()<block>
              super("{method.name}", new {method.name.charAt(0).toUpper + method.name.substring(1)}_argsSerializer(),  new {method.name.charAt(0).toUpper + method.name.substring(1)}_resultSerializer());
            </block>
            {
            if(method.doc != null && method.doc.contains("@SoaAsyncFunction") && {toJavaDataType(method.response.getFields.get(0).getDataType)}!= DataType.KIND.VOID)
              <div>
                @Override
                public {method.name}_result getResult(I iface, {method.name}_args args) throws TException<block>
                return null;
              </block>

                @Override
                public Future{lt}{method.name}_result{gt} getResultAsync(I iface, {method.name}_args args) throws TException <block>

                CompletableFuture{lt}{method.name}_result{gt} result = new CompletableFuture{lt}{gt}();
                {toFieldArrayBuffer(method.getResponse().getFields()).map{(field:Field)=>
                  <div>
                    CompletableFuture{lt}{toJavaDataType(method.response.getFields.get(0).getDataType)}{gt} realResult = (CompletableFuture{lt}{toJavaDataType(method.response.getFields.get(0).getDataType)}{gt}) iface.{method.name}({toFieldArrayBuffer(method.getRequest.getFields).map{ (field: Field) =>{<div>args.{field.name}{if(field != method.getRequest.fields.get(method.getRequest.fields.size() - 1)) <span>,</span>}</div>}}});
                  </div>
                }}
                realResult.whenComplete((str, ex) -> <block>
                  if (str != null) <block>
                    {method.name}_result r = new {method.name}_result();
                    r.setSuccess(str);
                    result.complete(r);
                  </block> else <block>
                    result.completeExceptionally(ex);
                  </block>
                </block>);
                return result;
              </block>
              </div>
            else <div>
              @Override
              public {method.name}_result getResult(I iface, {method.name}_args args) throws TException<block>
                {method.name}_result result = new {method.name}_result();
                {toFieldArrayBuffer(method.getResponse().getFields()).map{(field:Field)=>
                  if(field.getDataType().getKind() == DataType.KIND.VOID) {
                    <div>
                      iface.{method.name}({toFieldArrayBuffer(method.getRequest.getFields).map{ (field: Field) =>{<div>args.{field.name}{if(field != method.getRequest.fields.get(method.getRequest.fields.size() - 1)) <span>,</span>}</div>}}});
                    </div>
                  } else {
                    <div>
                      result.success = iface.{method.name}({toFieldArrayBuffer(method.getRequest.getFields).map{ (field: Field) =>{<div>args.{field.name}{if(field != method.getRequest.fields.get(method.getRequest.fields.size() - 1)) <span>,</span>}</div>}}});
                    </div>
                  }
                }}
                return result;
              </block>
            </div>
            }

            @Override
            public {method.name}_args getEmptyArgsInstance()<block>
              return new {method.name}_args();
            </block>

            @Override
            protected boolean isOneway()<block>
              return false;
            </block>
          </block>
          </div>
        }
        }
        }

        public static class getServiceMetadata{lt}I extends {service.namespace}.{service.name}{gt} extends SoaProcessFunction{lt}I, GetServiceMetadata_args, GetServiceMetadata_result, GetServiceMetadata_argsSerializer, GetServiceMetadata_resultSerializer{gt} <block>
          public getServiceMetadata() <block>
            super("getServiceMetadata", new GetServiceMetadata_argsSerializer(), new GetServiceMetadata_resultSerializer());
          </block>

          @Override
          public GetServiceMetadata_result getResult(I iface, GetServiceMetadata_args args) throws TException <block>
            GetServiceMetadata_result result = new GetServiceMetadata_result();

            try (InputStreamReader isr = new InputStreamReader({service.name}Codec.class.getClassLoader().getResourceAsStream("{service.namespace}.{service.name}.xml"));
            BufferedReader in = new BufferedReader(isr)) <block>
              int len = 0;
              StringBuilder str = new StringBuilder("");
              String line;
              while ((line = in.readLine()) != null) <block>

                if (len != 0) <block>
                  str.append("\r\n").append(line);
                </block> else <block>
                  str.append(line);
                </block>
                len++;
              </block>
              result.setSuccess(str.toString());

            </block> catch (Exception e) <block>
              e.printStackTrace();
              result.setSuccess("");
            </block>

            return result;
          </block>

          @Override
          public GetServiceMetadata_args getEmptyArgsInstance() <block>
            return new GetServiceMetadata_args();
          </block>

          @Override
          protected boolean isOneway() <block>
            return false;
          </block>
        </block>

        @SuppressWarnings("unchecked")
        public static class Processor{lt}I extends {service.getNamespace + "." + service.name}{gt} extends SoaCommonBaseProcessor<block>
          public Processor(I iface)<block>
            super(iface, getProcessMap(new java.util.HashMap{lt}{gt}()));
          </block>

          @SuppressWarnings("unchecked")
          private static {lt}I extends {service.getNamespace + "." + service.name}{gt} java.util.Map{lt}String, SoaProcessFunction{lt}I, ?, ?, ? extends TCommonBeanSerializer{lt}?{gt}, ? extends TCommonBeanSerializer{lt}?{gt}{gt}{gt} getProcessMap(java.util.Map{lt}String, SoaProcessFunction{lt}I, ?, ?, ? extends TCommonBeanSerializer{lt}?{gt}, ? extends TCommonBeanSerializer{lt}?{gt}{gt}{gt} processMap)<block>
            {
            toMethodArrayBuffer(service.getMethods).map{(method: Method)=>{
              <div>
                processMap.put("{method.name}", new {method.name}());
              </div>
            }
            }
            }
            processMap.put("getServiceMetadata", new getServiceMetadata());

            return processMap;
          </block>
        </block>

        </block>
      </div>
    }
  }

  def toJavaDataType(dataType:DataType): Elem = {
    dataType.kind match {
      case KIND.VOID => <div>void</div>
      case KIND.BOOLEAN => <div>Boolean</div>
      case KIND.BYTE => <div>Byte</div>
      case KIND.SHORT => <div>Short</div>
      case KIND.INTEGER => <div>Integer</div>
      case KIND.LONG => <div>Long</div>
      case KIND.DOUBLE => <div>Double</div>
      case KIND.STRING => <div>String</div>
      case KIND.BINARY => <div>java.nio.ByteBuffer</div>
      case KIND.DATE => <div>java.util.Date</div>
      case KIND.BIGDECIMAL => <div>java.math.BigDecimal</div>
      case KIND.MAP =>
        return {<div>java.util.Map{lt}{toJavaDataType(dataType.getKeyType())}, {toJavaDataType(dataType.getValueType())}{gt}</div>}
      case KIND.LIST =>
        return {<div>java.util.List{lt}{toJavaDataType(dataType.getValueType())}{gt}</div>}
      case KIND.SET =>
        return {<div>java.util.Set{lt}{toJavaDataType(dataType.getValueType())}{gt}</div>}
      case KIND.ENUM =>
        val ref = dataType.getQualifiedName();
        return {<div>{ref}</div>}
      case KIND.STRUCT =>
        val ref = dataType.getQualifiedName();
        return {<div>{ref}</div>}
    }
  }


  def getToStringElement(field: Field): Elem = {
    <div>
      stringBuilder.append("\"").append("{field.name}").append("\":{if(field.dataType.kind == DataType.KIND.STRING) <div>\"</div>}").append({getToStringByDataType(field)}).append("{if(field.dataType.kind == DataType.KIND.STRING) <div>\"</div>},");
    </div>
  }

  def getToStringByDataType(field: Field):Elem = {
    if(field.dataType.kind == KIND.STRUCT) <div>this.{field.name} == null ? "null" : this.{field.name}.toString()</div> else <div>{field.name}</div>
  }

}
